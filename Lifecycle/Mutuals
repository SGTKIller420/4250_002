Chris Bragg, Chris Upham, David Edwards, Sophia Herrell, Jackson Denti

What is CMMI?

CMMI (Capability Maturity Model Integration) is basically the way an organization goes through the Tuckman model.

The Tuckman model is broken into four steps: forming, storming, norming, and performing.

CMMI goes through these stages: initial, managed, defined, quantitatively managed, and optimized:

- Initial: At this stage, processes are out of control and reactive in nature. 
Businesses operating here contend with an uncertain environment, leading to heightened 
risks and operational inefficiencies.
- Managed: Processes are characterized by a project-based approach and tend to be reactive in nature.
- Defined: Processes are thoroughly characterized and well-understood. The organization 
demonstrates a proactive stance rather than being primarily reactive. Additionally, 
there are standardized practices adopted across the organization for guidance.
- Quantitatively Managed: Processes are meticulously measured and tightly controlled. 
The organization relies on quantitative data to establish consistent processes that 
align with its strategic objectives.
- Optimized: Processes have achieved stability and flexibility. The organizational 
emphasis is squarely on continuous improvement and the ability to adapt to evolving circumstances.

Phase on Software Lifecycle:
1. Requirements Gathering and Analysis: In this initial phase, the project team works closely 
with stakeholders and clients to gather and analyze requirements. These requirements specify what 
the software should do and define its functionalities, constraints, and objectives.
2. Design: During this phase, the high-level system architecture and design are created. 
This includes defining the overall structure of the software, such as modules, components, and data flow.
In the detailed design the high-level design is translated into more detailed specifications. Design 
decisions related to databases, user interfaces, algorithms, and data structures are made.
3. Implementation (Coding): The actual coding or implementation of the software occurs in this phase. 
Developers write code based on the detailed design, creating the functional components and features 
of the software.
4. Testing: Software testing is a critical phase where the developed software is 
rigorously tested to ensure it meets the specified requirements. This includes functional 
testing, integration testing, performance testing, and more.
5. Release: Once the software has passed testing and quality assurance, it is deployed 
to the production environment or made available to end-users. Deployment strategies can vary, 
including gradual rollouts or full releases.
6. Maintenance: After deployment, the software enters a maintenance phase. 
This involves addressing and fixing any issues (bugs) that arise and providing ongoing support to users.
7. Upgrades/Updates: Slightly different from maintenance, upgrades/updates encompass larger changes
to the product, including added features. 

Results of Brainstorming Phase on Software Lifecycle:

Requirements: Identify the problem then define it
  •	Broken into mandatory/optional and functional/non-functional
  •	Many people involved – client, stockholder, developer…
  •	Discussing with the client what they need
  •	Prioritize requirements based on importance
  •	Sending the proposed requirements to the client
  •	Some requirements might have constraints on the solution
  •	How we can deem the product successfully created
  •	Precondition: A problem
  •	Postcondition: SRS (Software Requirements Specification)
  •	What needs to be done, not how
Design: figuring out how to implement the solution
  •	Is a traceability matric, maps key elements from the design back to the requirements document
  •	How the solution is implemented
  •	Multiple levels of design
  •	Documenting how a solution will be implemented
  •	Can include several systems that work together
  •	Often done breadth-first and iterated until an acceptable level of detail is reached
  •	Documentation should be within the implementation. Ex: self-documented code
  •	Precondition: SRS
  •	Postcondition: A detailed design
Implementation: code the product – the actual creation
  •	The most fun part
  •	Documenting the code
  •	Can consist of code, scripts, or hardware solutions
  •	Is traceability matrix back to the design phase
  •	Follows the design
  •	Additional members begin working on the project
  •	Precondition: a detailed design
  •	Postcondition: working software
Testing: checking that a product meets the requirements using robust test cases
  •	Making sure the product meets the requirements using robust test cases
  •	Identify edge cases and test them
  •	Find bugs in the software if there are any
  •	Many development organizations have a designated QA team
  •	Document testing with test plans
  •	Traceability matrix back to requirements
  •	Ensure that code meets requirements/behaves as expected
  •	Vital phase of the development
  •	Precondition: working software
  •	Postcondition: requirements traceability matrix’s, all tests produce desired results.
Release: putting the tested product into a production environment
  •	Preparing to rollback in case something burns down
  •	Multiple release stages. i.e pre-alpha, beta, etc.
  •	Release scripts handle various tasks such as deploying new versions, data migration
  •	There should be release notes that describe what it is, what is does, features, etc.
  •	Putting working software into a production environment
  •	Waterfall: often one release. Iterative model: periodic release. Agile/scrum: gib release with highly involved customers & frequent upgrades
Maintenance: After release, fix any problems or make improvements.
  •	Requires testing for the small changes
  •	Making sure the software does not die
  •	Often the most expensive phase
  •	Bug fixes made to the production release
  •	Generally released as patches
  •	Accompanied by original release docs. Any changes made are highlighted.
  •	Distinct from upgrades and updates.
Upgrades/Updates – repeat of the entire lifecycle from the requirements to support
  •	Not common with waterfall methodology
  •	Repeat the entire lifecycle
  •	Includes version increments
  •	Enhancements to the base. Common with OS, ERP, games, etc.
  •	Introduces new features
  •	Part of software with any real future
  •	Can be labor intensive
